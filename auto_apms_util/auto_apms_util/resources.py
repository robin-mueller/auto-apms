# Copyright 2025 Robin MÃ¼ller
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import os
import ament_index_python
import xml.etree.ElementTree as ET


class ResourceError(Exception):
    """Exception raised when resource operations fail."""

    pass


_AUTO_APMS_UTIL__RESOURCE_TYPE_NAME__PLUGINLIB = "auto_apms_util__pluginlib__plugins"


def get_packages_with_resource_type(resource_type: str, exclude_packages: set[str] = None) -> set[str]:
    """
    Get a list of all package names that register a certain type of ament_index resources.

    Note: This function determines what packages register resources by parsing the install
    directory, so any resources that are not installed at the time this function is called
    won't be considered.

    Args:
        resource_type: Name of the resource type.
        exclude_packages: Packages to exclude when searching for resources.

    Returns:
        Set of all packages that register resources of type resource_type excluding exclude_packages.

    Raises:
        ResourceError: If no resources of type resource_type were found in any of the installed packages.
    """
    if exclude_packages is None:
        exclude_packages = set()

    try:
        resources = ament_index_python.get_resources(resource_type)
        packages = set(resources.keys())
    except ament_index_python.PackageNotFoundError:
        packages = set()

    # Get common elements between packages and exclude_packages
    common = packages.intersection(exclude_packages)
    if common:
        for package_to_exclude in common:
            packages.discard(package_to_exclude)
        if not packages:
            common_list = sorted(list(common))
            raise ResourceError(
                f"Resources for type '{resource_type}' are only available in excluded but not in any other "
                f"of the installed packages (Excluded packages containing resources: [ {', '.join(common_list)} ])."
            )

    return packages


def get_packages_with_plugin_resources(exclude_packages: set[str] = None) -> set[str]:
    """
    Get a list of all package names that register AutoAPMS plugin resources.

    Note: This function determines what packages register resources by parsing the install
    directory, so any resources that are not installed at the time this function is called
    won't be considered.

    Args:
        exclude_packages: Packages to exclude when searching for resources.

    Returns:
        Set of all packages that register AutoAPMS plugins excluding exclude_packages.

    Raises:
        ResourceError: If no AutoAPMS plugin resources were found in any of the installed packages.
    """
    return get_packages_with_resource_type(_AUTO_APMS_UTIL__RESOURCE_TYPE_NAME__PLUGINLIB, exclude_packages)


def get_plugin_xml_path(package: str) -> str:
    """
    Get the path of a specific plugins.xml manifest file generated by AutoAPMS.

    This function will discover the plugins.xml manifest file of a specific package. It will only work for packages that
    use the CMake macro auto_apms_util_register_plugins() to register plugins.

    Args:
        package: Name of the package registering AutoAPMS plugin resources.

    Returns:
        Absolute path to the pluginlib-style plugin manifest xml file.

    Raises:
        ResourceError: If failed to find a plugin manifest file.
        ResourceError: If an ament_index resource marker file is invalid.
    """
    try:
        content, base_path = ament_index_python.get_resource(_AUTO_APMS_UTIL__RESOURCE_TYPE_NAME__PLUGINLIB, package)
    except ament_index_python.PackageNotFoundError:
        raise ResourceError(
            f"Cannot find a plugin.xml file in package '{package}' "
            f"(Plugin resource type is: '{_AUTO_APMS_UTIL__RESOURCE_TYPE_NAME__PLUGINLIB}')."
        )

    paths = content.strip().split("\n")
    if len(paths) != 1:
        raise ResourceError(
            f"Invalid '{_AUTO_APMS_UTIL__RESOURCE_TYPE_NAME__PLUGINLIB}' resource marker file installed by package '{package}'. "
            f"Must contain a single line with a relative path to the plugins.xml manifest file "
            f"with respect to the package's install prefix."
        )

    return os.path.join(base_path, paths[0])


def collect_plugin_xml_paths(exclude_packages: set[str] = None) -> list[str]:
    """
    Collect the paths of plugins.xml manifest files generated by AutoAPMS.

    This function will find all plugins.xml manifest files which are automatically populated
    using the CMake macro auto_apms_util_register_plugins().

    Args:
        exclude_packages: Packages to exclude when searching for plugins.xml file paths.

    Returns:
        List of absolute paths to the pluginlib-style plugin manifest xml files.

    Raises:
        ResourceError: If failed to find a plugin manifest file.
        ResourceError: If an ament_index resource marker file is invalid.
    """
    xml_paths = []
    packages = get_packages_with_resource_type(_AUTO_APMS_UTIL__RESOURCE_TYPE_NAME__PLUGINLIB, exclude_packages)
    for package in packages:
        xml_paths.append(get_plugin_xml_path(package))
    return xml_paths


def get_plugin_names_with_base_type(base_class_type: str, exclude_packages: set[str] = None) -> list[str]:
    """
    Find all plugin names that have a specific base class type from plugin XML manifest files.

    This function parses all available plugin XML manifest files and returns the names of all
    plugins that match the specified base class type.

    Args:
        base_class_type: Fully qualified name of the base class type to search for.
        exclude_packages: Packages to exclude when searching for plugins.

    Returns:
        List of plugin names (class names) that have the specified base class type.

    Raises:
        ResourceError: If failed to find or parse a plugin manifest file.
    """
    plugin_names = []
    xml_paths = collect_plugin_xml_paths(exclude_packages)

    for xml_path in xml_paths:
        try:
            # Read the file content and preprocess it to fix XML encoding issues
            with open(xml_path, "r", encoding="utf-8") as f:
                content = f.read()

            # Fix unescaped angle brackets in all attribute values
            # This handles cases like name="Class<Template>" and type="Template<Class>"
            import re

            # Find all attributes and fix the angle brackets within their values
            def fix_attribute(match):
                attr_name = match.group(1)
                attr_value = match.group(2)
                # Replace unescaped < and > with their escaped versions
                escaped_value = attr_value.replace("<", "&lt;").replace(">", "&gt;")
                # Return the full attribute with escaped value
                return f'{attr_name}="{escaped_value}"'

            # Apply the fix to all attributes that contain angle brackets
            content = re.sub(r'(\w+)="([^"]*[<>][^"]*)"', fix_attribute, content)

            # Parse the preprocessed content
            root = ET.fromstring(content)

            # Find all class elements with matching base_class_type
            for library in root.findall("library"):
                for class_elem in library.findall("class"):
                    if class_elem.get("base_class_type") == base_class_type:
                        plugin_name = class_elem.get("name")
                        if plugin_name:
                            plugin_names.append(plugin_name)

        except ET.ParseError as e:
            raise ResourceError(f"Failed to parse plugin XML manifest file '{xml_path}': {e}")
        except Exception as e:
            raise ResourceError(f"Error reading plugin XML manifest file '{xml_path}': {e}")

    return plugin_names
