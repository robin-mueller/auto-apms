// Copyright 2024 Robin MÃ¼ller
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#pragma once

#include <map>
#include <vector>

#include "auto_apms_behavior_tree_core/definitions.hpp"
#include "auto_apms_behavior_tree_core/node/node_registration_options.hpp"
#include "auto_apms_util/exceptions.hpp"
#include "auto_apms_util/yaml.hpp"

namespace auto_apms_behavior_tree::core
{

/**
 * @brief Struct that encapsulates the identity string for a registered behavior tree node manifest.
 */
struct NodeManifestResourceIdentity
{
  /**
   * @brief Constructor of a node manifest resource identity object.
   *
   * @p identity must be formatted like `<package_name>::<metadata_id>`.
   * @param identity Identity string for a specific node manifest.
   * @throws auto_apms_util::exceptions::ResourceIdentityFormatError if the identity string has wrong format.
   */
  NodeManifestResourceIdentity(const std::string & identity);

  /**
   * @brief Constructor of a behavior resource identity object.
   *
   * @p identity must be formatted like `<package_name>::<metadata_id>`.
   * @param identity C-style identity string for a specific node manifest resource.
   * @throws auto_apms_util::exceptions::ResourceIdentityFormatError if the identity string has wrong format.
   */
  NodeManifestResourceIdentity(const char * identity);

  /**
   * @brief Constructor of an empty node manifest resource identity object.
   *
   * The user must manually populate the member fields.
   */
  NodeManifestResourceIdentity() = default;

  virtual ~NodeManifestResourceIdentity() = default;

  bool operator==(const NodeManifestResourceIdentity & other) const;

  bool operator<(const NodeManifestResourceIdentity & other) const;

  /**
   * @brief Create the corresponding identity string.
   * @return Identity string for a node manifest resource.
   */
  std::string str() const;

  /**
   * @brief Determine whether this node manifest resource identity object is considered empty.
   * @return `true` if none of the member fields are set, `false` otherwise.
   */
  bool empty() const;

  /// Name of the package that registers the behavior resource.
  std::string package_name;
  /// Metadata ID determined when regitering the corresponding node manifest resource.
  std::string metadata_id;
};

/**
 * @ingroup auto_apms_behavior_tree
 * @brief Get all registered behavior tree node manifest resource identities.
 * @param exclude_packages Optional set of package names to exclude from the search. If empty, all packages are
 * included.
 * @return Set of `NodeManifestResourceIdentity` objects representing all registered node manifest resources.
 */
std::set<NodeManifestResourceIdentity> getNodeManifestResourceIdentities(
  const std::set<std::string> & exclude_packages = {});

/**
 * @ingroup auto_apms_behavior_tree
 * @brief Data structure for information about which behavior tree node plugin to load and how to configure them.
 *
 * The concept of a node manifest is introduced to enable TreeDocument to dynamically load and register an arbitrary
 * amount of behavior tree node plugins implemented by ROS 2 packages. The node manifest contains information
 * about the individual registration options required at construction time and the names that must be used inside the
 * behavior tree to refer to respective node implementations.
 *
 * Usually, the user doesn't need to worry about creating instances of this class manually, since a node manifest is
 * automatically assembled when creating a behavior tree using a **behavior tree resource**. These resources are
 * generated by the CMake macro `auto_apms_behavior_tree_register_trees` inside a CMakeLists.txt of a package. It's also
 * possible to create **node manifest resources** using the CMake macro `auto_apms_behavior_tree_register_nodes`. Both
 * macros may take an argument named `NODE_MANIFEST` that accepts multiple paths to YAML files specifying the
 * corresponding node manifest. The content of the files will be concatenated to a single node manifest.
 *
 *  ```cmake
 * # Creates a behavior tree resource
 * auto_apms_behavior_tree_register_trees(
 *     ... # Behavior tree XML file paths
 *     NODE_MANIFEST
 *     "path/to/manifest/file1.yaml"
 *     "path/to/manifest/file2.yaml"
 *     ...
 * )
 *
 * # Creates a node manifest resource
 * auto_apms_behavior_tree_register_nodes(node_library_target
 *     ... # Fully qualified class names of the node plugins
 *     NODE_MANIFEST
 *     "path/to/manifest/file1.yaml"
 *     "path/to/manifest/file2.yaml"
 *     ...
 * )
 * ```
 *
 * The YAML format for a node manifest file is defined
 * [here](https://autoapms.github.io/auto-apms-guide/concept/common-resources#behavior-tree-node-manifests)
 *
 */
class NodeManifest
{
public:
  using RegistrationOptions = NodeRegistrationOptions;

  /// Mapping of a node's name and its registration parameters.
  using Map = std::map<std::string, NodeRegistrationOptions>;

  /**
   * @brief Constructor of a NodeManifest data structure.
   *
   * The manifest is empty initially, but you may provide a map to initialize it.
   * @param map Initial manifest data.
   */
  NodeManifest(const Map & map = {});

  AUTO_APMS_UTIL_DEFINE_YAML_CONVERSION_METHODS(NodeManifest)

  /**
   * @brief Create a node plugin manifest from multiple files. They are loaded in the given order.
   * @param paths Paths to the manifest files.
   * @throw auto_apms_behavior_tree::exceptions::NodeManifestError if NodeManifest::merge fails for any file.
   */
  static NodeManifest fromFiles(const std::vector<std::string> & paths);

  /**
   * @brief Create a node manifest from an installed resource.
   * @param search_identity Node manifest resource identity used for searching the corresponding resource.
   * @return Node manifest created from the corresponding resource.
   * @throw auto_apms_util::exceptions::ResourceIdentityFormatError if @p identity has wrong format.
   * @throw auto_apms_util::exceptions::ResourceError if resource cannot be determined using @p identity.
   */
  static NodeManifest fromResource(const NodeManifestResourceIdentity & search_identity);

  /**
   * @brief Write the node manifest to a file.
   * @param file_path Path to the target file.
   * @throw auto_apms_behavior_tree::exceptions::NodeManifestError if file cannot be opened.
   */
  void toFile(const std::string & file_path) const;

  /**
   * @brief Determine if a behavior tree node has been added to the manifest.
   * @param node_name Name of the behavior tree node.
   * @return `true` if name is existing, `false` otherwise.
   */
  bool contains(const std::string & node_name) const;

  /**
   * @brief Access the node manifest and retrieve registration options for a specific behavior tree node.
   * @param node_name Name of the behavior tree node.
   * @return Registration options for @p node_name.
   * @throw std::out_of_range if @p node_name doesn't exist.
   */
  RegistrationOptions & operator[](const std::string & node_name);

  /// @copydoc NodeManifest::operator[]
  const RegistrationOptions & operator[](const std::string & node_name) const;

  /**
   * @brief Add registration options for a behavior tree node to the manifest.
   * @param node_name Name of the behavior tree node.
   * @param opt Registration options to be used when loading the behavior tree node.
   * @return Modified node manifest.
   * @throw auto_apms_behavior_tree::exceptions::NodeManifestError if the registration options are invalid or
   * `node_name` already exists.
   */
  NodeManifest & add(const std::string & node_name, const RegistrationOptions & opt);

  /**
   * @brief Remove registration options for a behavior tree node.
   * @param node_name Name of the behavior tree node.
   * @return Modified node manifest.
   * @throw std::out_of_range if @p node_name doesn't exist.
   */
  NodeManifest & remove(const std::string & node_name);

  /**
   * @brief Merges another NodeManifest with this one.
   *
   * Since the functional characteristics of a node with the same name but different registration options
   * can be fundamentally different, this method will throw if it comes across a registration name in @p other that
   * already exists in this node manifest unless @p replace is `true`.
   * @param other Other node manifest.
   * @param replace `true` for automatically replacing entries with the same key (same registration name). Throws an
   * error if `false` and @p other contains any keys that already exist in this manifest.
   * @return Modified node manifest.
   * @throw auto_apms_behavior_tree::exceptions::NodeManifestError if any node name from @p other already exists in this
   * node manifest and @p replace is `false`.
   */
  NodeManifest & merge(const NodeManifest & other, bool replace = false);

  /**
   * @brief Merges another NodeManifest with this one using a namespace for the registration names.
   *
   * Since the functional characteristics of a node with the same name but different registration options
   * can be fundamentally different, this method will add a namespace as a prefix to all registration names from
   * @p other.
   * @param other Other node manifest.
   * @param with_namespace Prefix to add to all node names from @p other.
   * @param sep Separator string to use between the namespace and the node name.
   * @return Modified node manifest.
   * @throw auto_apms_behavior_tree::exceptions::NodeManifestError if any node name from @p other already exists in
   * this manifest (after applying the namespace prefix).
   */
  NodeManifest & mergeWithNamespace(
    const NodeManifest & other, const std::string & with_namespace, const std::string & sep = ".");

  /**
   * @brief Apply a namespace prefix to all node names in this manifest.
   * @param ns Namespace prefix to apply.
   * @param sep Separator string to use between the namespace and the node name.
   * @return Modified node manifest.
   */
  NodeManifest & applyNodeNamespace(
    const std::string & ns, const std::string & sep = _AUTO_APMS_BEHAVIOR_TREE_CORE__NODE_NAMESPACE_DEFAULT_SEP);

  /**
   * @brief Get all names of the behavior tree nodes specified by the manifest.
   * @return Vector of all available node names.
   */
  std::vector<std::string> getNodeNames();

  /**
   * @brief Get the number of behavior tree nodes this manifest holds registration options for.
   * @return Size of this node manifest.
   */
  size_t size() const;

  /**
   * @brief Determine whether any node registration options have been added to the manifest.
   * @return `true` if the node manifest is empty, `false` otherwise.
   */
  bool empty() const;

  /**
   * @brief Get a view of the internal map.
   * @return Internal map of the node manifest.
   */
  const Map & map() const;

private:
  Map map_;
};

/**
 * @brief Class containing behavior tree node manifest resource data.
 */
class NodeManifestResource
{
public:
  using Identity = NodeManifestResourceIdentity;

  /**
   * @brief Constructor of a node manifest resource object.
   * @param search_identity Node manifest resource identity used for searching the corresponding resource.
   * @throws auto_apms_util::exceptions::ResourceIdentityFormatError if @p search_identity has wrong format.
   * @throws auto_apms_util::exceptions::ResourceError if resource cannot be determined using @p search_identity.
   * @throws auto_apms_behavior_tree::exceptions::NodeManifestError if the resource is not a valid node manifest.
   */
  NodeManifestResource(const Identity & search_identity);

  /**
   * @brief Constructor of a node manifest resource object.
   * @param search_identity Node manifest resource identity string used for searching the corresponding resource.
   * @throws auto_apms_util::exceptions::ResourceIdentityFormatError if @p search_identity has wrong format.
   * @throws auto_apms_util::exceptions::ResourceError if resource cannot be determined using @p search_identity.
   * @throws auto_apms_behavior_tree::exceptions::NodeManifestError if the resource is not a valid node manifest.
   */
  NodeManifestResource(const std::string & search_identity);

  /**
   * @brief Constructor of a node manifest resource object.
   * @param search_identity C-style Nnode manifest resource identity string used for searching the corresponding
   * resource.
   * @throws auto_apms_util::exceptions::ResourceIdentityFormatError if @p search_identity has wrong format.
   * @throws auto_apms_util::exceptions::ResourceError if resource cannot be determined using @p search_identity.
   * @throws auto_apms_behavior_tree::exceptions::NodeManifestError if the resource is not a valid node manifest.
   */
  NodeManifestResource(const char * search_identity);

  /**
   * @brief Get the unique identity for this resource.
   * @return Identity object.
   */
  const Identity & getIdentity() const;

  /**
   * @brief Get the node manifest object associated with this resource.
   * @return Node manifest object.
   */
  const NodeManifest & getNodeManifest() const;

  /**
   * @brief Get the node model object associated with this resource.
   * @return Node model object.
   */
  const NodeModelMap & getNodeModel() const;

private:
  Identity unique_identity_;
  std::string node_manifest_file_path_;
  NodeManifest node_manifest_;
  std::string node_model_file_path_;
  NodeModelMap node_model_;
};

}  // namespace auto_apms_behavior_tree::core

// #####################################################################################################################
// ################################              DEFINITIONS              ##############################################
// #####################################################################################################################

/// @cond INTERNAL
namespace YAML
{
template <>
struct convert<auto_apms_behavior_tree::core::NodeManifestResourceIdentity>
{
  using Identity = auto_apms_behavior_tree::core::NodeManifestResourceIdentity;
  static Node encode(const Identity & rhs)
  {
    Node node;
    node = rhs.str();
    return node;
  }
  static bool decode(const Node & node, Identity & rhs)
  {
    if (!node.IsScalar()) return false;
    rhs = Identity(node.Scalar());
    return true;
  }
};
template <>
struct convert<auto_apms_behavior_tree::core::NodeManifest>
{
  using Manifest = auto_apms_behavior_tree::core::NodeManifest;
  inline static Node encode(const Manifest & rhs)
  {
    Node node(NodeType::Map);
    for (const auto & [name, params] : rhs.map()) node[name] = params;
    return node;
  }
  inline static bool decode(const Node & node, Manifest & rhs)
  {
    if (!node.IsMap())
      throw auto_apms_util::exceptions::YAMLFormatError(
        "YAML::Node for auto_apms_behavior_tree::core::NodeManifest must be map but is type " +
        std::to_string(node.Type()) + " (0: Undefined - 1: Null - 2: Scalar - 3: Sequence - 4: Map).");

    for (auto it = node.begin(); it != node.end(); ++it) {
      const auto & name = it->first.as<std::string>();
      try {
        rhs.add(name, it->second.as<Manifest::RegistrationOptions>());
      } catch (const std::exception & e) {
        throw auto_apms_util::exceptions::YAMLFormatError(
          "Node registration options for node '" + name + "' are invalid: " + e.what());
      }
    }
    return true;
  }
};
}  // namespace YAML
/// @endcond
